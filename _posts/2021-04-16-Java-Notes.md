---
layout:     post   				    # 使用的布局（不需要改）
title:      Java Notes		# 标题 
subtitle:   Java笔记（再学一遍！！） #副标题
date:       2021-04-16			# 时间
author:     Leo 						# 作者
header-img: img/post-bg-java.png	#这篇文章标题背景图片
catalog: true 						# 是否归档
tags:								#标签
    - Programming Language
    - Java
---

# 1 数据类型

## 1.1 基本数据类型

基本数据类型：有着固定数据，范围的数据类型

整数型：byte short int long<br>
浮点型: float double<br>
字符：  char 0-65535 unicode<br>
布尔：  boolean 0/1<br>

传值,  `==`  比较值

## 1.2 引用数据类型

引用数据类型：没有固定长度尺寸、范围，初始默认为null

数组： `int arr[] = null`   `arr = new int[10]`<br>
字符串： `String str = null`<br>
类（接口），对象: `Object obj = null`<br>

传引用，`==`  比较地址

>Q:String的长度最大为多少？<br>
A:String的底层是一个char数组，所以String的最大长度为数组的最大长度，可参照数组的length属性，一个32位的有符号整数，最大值为2<sup>31</sup>-1，即2G.

# 2 面向对象

## 2.1 类——封装

Java 语言的基本封装单位是类。由于类的用途是封装复杂性，所以类的内部有隐藏实现复杂性的机制。Java 提供了私有和公有的访问模式，类的公有接口代表外部的用户应该知道或可以知道的每件东西，私有的方法数据只能通过该类的成员代码来访问，这就可以确保不会发生不希望的事情。

类中包含：属性，方法，代码块（创建对象时调用）

### 2.1.1 访问修饰符

- public<br>
  整个项目可见
- private<br>
  仅当前类可见
- default(缺省)<br>
  包内可见
- protected<br>
  包内以及不同包的子类可见

### 2.1.2 final,static

- final<br>
最终形态，不可变<br>
final 修饰的 属性、类，不可被继承<br>方法不能被重写

- static<br>
静态，唯一<br>
static修饰的属性，方法不属于对象，属于类，可由类名直接调用<br>
static修饰的代码块仅在创建对象时会被执行一次

## 2.2 继承

如同生活中的子女继承父母拥有的所有财产，程序中的继承性是指子类拥有父类的全部特征和行为，这是类之间的一种关系。

Java 只支持单继承。

子类可以继承父类的一切（但是访问受限）

### 2.2.1 子类及其对象可调用内容

- 同包：只有private不能调用
- 不同包：
  - 在子类中，protected,public可调用；
  - 在非子类中，子类对象只能调用public

### 2.2.2 方法重写

在子类中如果创建了一个与父类中相同名称、相同返回值类型、相同参数列表的方法，只是方法体中的实现不同，以实现不同于父类的功能，这种方式被称为方法重写（override），又称为方法覆盖。当父类中的方法无法满足子类需求或子类具有特有功能的时候，需要方法重写。

重写的注意点：

- 参数列表必须完全与被重写的方法参数列表相同。
- 返回的类型必须与被重写的方法的返回类型相同 *（Java1.5 版本之前返回值类型必须一样，之后的 Java 版本放宽了限制，返回值类型必须小于或者等于父类方法的返回值类型）*。
- 访问权限不能比父类中被重写方法的访问权限更低（public>protected>default>private）。
- 声明为 final，static的方法不能被重写，但是static可以再次声明。
- 子类和父类在同一个包中时，子类可以重写父类的所有方法，除了声明为 private 和 final 的方法。
- 子类和父类不在同一个包中时，子类只能重写父类的声明为 public 和 protected 的非 final 方法。
- 重写方法一定不能抛出新的检査异常或者比被重写方法声明更加宽泛的检査型异常。例如，父类的一个方法声明了一个检査异常 IOException，在重写这个方法时就不能抛出 Exception，只能拋出 IOException 的子类异常，可以抛出非检査异常。
- 可以使用`@override`来检查是否重写正确。

### 2.2.3 接口

- 抽象类：

    抽象类的定义和使用规则如下：

    - 抽象类和抽象方法都要使用 abstract 关键字声明。
    - 如果一个方法被声明为抽象的，那么这个类也必须声明为抽象的。而一个抽象类中，可以有 0~n 个抽象方法，以及 0~n 个具体方法。
    - 抽象类不能实例化，也就是不能使用 new 关键字创建对象。

- 抽象方法：

    - 抽象方法没有方法体

    - 抽象方法必须存在于抽象类中

    - 子类重写父类时，必须重写父类所有的抽象方法

- 接口

抽象类是从多个类中抽象出来的模板，如果将这种抽象进行的更彻底，则可以提炼出一种更加特殊的“抽象类”——接口（Interface）。

接口中可包含常量（隐式声明为public,static,final，必须被初始化）和一组抽象方法(隐式声明为public,abstract)c。

一个接口可以有多个父接口，但接口只能继承接口，不能继承类。

一个接口不能够实现另一个接口，但它可以继承多个其他接口。子接口可以对父接口的方法和常量进行重写。

接口的主要用途就是被实现类实现，一个类可以实现一个或多个接口，继承使用 extends 关键字，实现则使用 implements 关键字。因为一个类可以实现多个接口，这也是 Java 为单继承灵活性不足所作的补充。

一个类实现了一个或多个接口之后，这个类必须完全实现这些接口里所定义的全部抽象方法（也就是重写这些抽象方法）；否则，该类将保留从父接口那里继承到的抽象方法，该类也必须定义成抽象类。


## 2.3 多态

多态是指在父类中定义的属性和方法被子类继承之后，可以具有不同的数据类型或表现出不同的行为，这使得同一个属性或方法在父类及其各个子类中具有不同的含义。

对面向对象来说，多态分为编译时多态和运行时多态。其中编译时多态是静态的，主要是指方法的**重载**，它是根据参数列表的不同来区分不同的方法。通过编译之后会变成两个不同的方法，在运行时谈不上多态。而运行时多态是动态的，它是通过动态绑定来实现的，也就是大家通常所说的多态性。

Java 实现多态有 3 个必要条件：继承、重写和向上转型。只有满足这 3 个条件，开发人员才能够在同一个继承结构中使用统一的逻辑实现代码处理不同的对象，从而执行不同的行为。

继承：在多态中必须存在有继承关系的子类和父类。

重写：子类对父类中某些方法进行重新定义，在调用这些方法时就会调用子类的方法。

向上转型：在多态中需要将子类的引用赋给父类对象，只有这样该引用才既能可以调用父类的方法，又能调用子类的方法。

